//
//  SessionsListWatchView.swift
//  ShlfWatch Watch App
//
//  Created by João Fernandes on 28/11/2025.
//

import SwiftUI
import SwiftData
import OSLog

struct SessionsListWatchView: View {
    @Environment(\.modelContext) private var modelContext
    let book: Book

    @Query(sort: \ReadingSession.startDate, order: .reverse) private var allSessions: [ReadingSession]
    @Query private var profiles: [UserProfile]

    private var profile: UserProfile? {
        profiles.first
    }

    private var bookSessions: [ReadingSession] {
        let hideAuto = profile?.hideAutoSessionsWatch ?? false
        return allSessions.filter { session in
            guard let sessionBook = session.book else {
                return false
            }
            if sessionBook.id != book.id {
                return false
            }
            // Filter out auto-generated sessions if Watch setting is enabled
            if hideAuto && session.isAutoGenerated {
                return false
            }
            return true
        }
    }

    private var trackedBookSessions: [ReadingSession] {
        bookSessions.filter { $0.countsTowardStats }
    }

    private var todaysSessions: [ReadingSession] {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        return bookSessions.filter { calendar.isDate($0.startDate, inSameDayAs: today) }
    }

    private var todaysTrackedSessions: [ReadingSession] {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        return trackedBookSessions.filter { calendar.isDate($0.startDate, inSameDayAs: today) }
    }

    private var olderSessions: [ReadingSession] {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        return bookSessions.filter { !calendar.isDate($0.startDate, inSameDayAs: today) }
    }

    var body: some View {
        List {
            // Today's Summary
            if !todaysTrackedSessions.isEmpty {
                Section {
                    TodaysSummaryCard(sessions: todaysTrackedSessions)
                }
            }

            // Today's Sessions
            if !todaysSessions.isEmpty {
                Section("Today") {
                    ForEach(todaysSessions) { session in
                        NavigationLink(destination: SessionDetailWatchView(session: session)) {
                            SessionRowWatch(session: session)
                        }
                    }
                }
            }

            // Older Sessions
            if !olderSessions.isEmpty {
                Section("Earlier") {
                    ForEach(olderSessions.prefix(10)) { session in
                        NavigationLink(destination: SessionDetailWatchView(session: session)) {
                            SessionRowWatch(session: session)
                        }
                    }
                }
            }

            // Empty State
            if bookSessions.isEmpty {
                VStack(spacing: 8) {
                    Image(systemName: "book.closed")
                        .font(.largeTitle)
                        .foregroundStyle(.secondary)

                    Text("No Sessions Yet")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                .frame(maxWidth: .infinity)
                .padding()
            }
        }
        .navigationTitle("Sessions")
        .navigationBarTitleDisplayMode(.inline)
    }
}

struct TodaysSummaryCard: View {
    let sessions: [ReadingSession]

    private var totalPages: Int {
        // CRITICAL: Clamp to non-negative (user can go backwards)
        max(0, sessions.reduce(0) { $0 + ($1.endPage - $1.startPage) })
    }

    private var totalMinutes: Int {
        sessions.reduce(0) { $0 + $1.durationMinutes }
    }

    private var totalXP: Int {
        sessions.reduce(0) { $0 + $1.xpEarned }
    }

    var body: some View {
        VStack(spacing: 8) {
            HStack(spacing: 16) {
                StatItem(icon: "book.fill", value: "\(totalPages)", label: "pages")
                StatItem(icon: "clock.fill", value: "\(totalMinutes)", label: "min")
                StatItem(icon: "star.fill", value: "\(totalXP)", label: "XP")
            }
        }
        .padding(.vertical, 4)
    }
}

struct StatItem: View {
    @Environment(\.themeColor) private var themeColor
    let icon: String
    let value: String
    let label: String

    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon)
                .foregroundStyle(themeColor.color)
                .font(.caption)

            Text(value)
                .font(.headline)
                .fontWeight(.semibold)

            Text(label)
                .font(.caption2)
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity)
    }
}

struct SessionRowWatch: View {
    @Environment(\.themeColor) private var themeColor
    let session: ReadingSession

    private var timeAgo: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .short
        return formatter.localizedString(for: session.startDate, relativeTo: Date())
    }

    private var metricsText: String {
        let pages = session.pagesRead >= 0 ? "+\(session.pagesRead)" : "\(session.pagesRead)"
        return "\(pages) • \(session.durationMinutes) min • \(timeAgo)"
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(session.displayName)
                    .font(.headline)
                Spacer()
                Text("\(session.xpEarned) XP")
                    .font(.caption)
                    .foregroundStyle(themeColor.color)
            }

            if session.isImported || !session.countsTowardStats {
                Text("Imported")
                    .font(.caption2.weight(.semibold))
                    .foregroundStyle(.orange)
            }

            Text(metricsText)
                .font(.caption)
                .foregroundStyle(.secondary)
                .lineLimit(1)
                .minimumScaleFactor(0.75)
                .allowsTightening(true)
                .layoutPriority(1)
        }
    }
}

#Preview {
    NavigationStack {
        SessionsListWatchView(book: Book(
            title: "Test Book",
            author: "Test Author",
            currentPage: 100,
            bookType: .physical,
            readingStatus: .currentlyReading
        ))
    }
}
