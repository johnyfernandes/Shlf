//
//  WatchConnectivityManager.swift
//  ShlfWatch Watch App
//
//  Created by Jo√£o Fernandes on 27/11/2025.
//

import Foundation
import WatchConnectivity
import SwiftData
import OSLog

struct PageDelta: Codable, Sendable {
    let bookUUID: UUID
    let delta: Int
}

struct BookTransfer: Codable, Sendable {
    let id: UUID
    let title: String
    let author: String
    let isbn: String?
    let coverImageURL: String?
    let totalPages: Int?
    let currentPage: Int
    let bookTypeRawValue: String
    let readingStatusRawValue: String
    let dateAdded: Date
    let notes: String
}

struct SessionTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let startDate: Date
    let endDate: Date?
    let startPage: Int
    let endPage: Int
    let durationMinutes: Int
    let xpEarned: Int
    let isAutoGenerated: Bool
}

struct ProfileSettingsTransfer: Codable, Sendable {
    let hideAutoSessionsIPhone: Bool
    let hideAutoSessionsWatch: Bool
}

struct ProfileStatsTransfer: Codable, Sendable {
    let totalXP: Int
    let currentStreak: Int
    let longestStreak: Int
    let lastReadingDate: Date?
}

class WatchConnectivityManager: NSObject {
    static let shared = WatchConnectivityManager()
    nonisolated(unsafe) static let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "com.shlf.watch", category: "WatchSync")
    private var modelContext: ModelContext?

    private override init() {
        super.init()
    }

    func configure(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func activate() {
        guard WCSession.isSupported() else { return }
        let session = WCSession.default
        session.delegate = self
        session.activate()
        Self.logger.info("WatchConnectivity activated on Watch")
    }

    func sendPageDelta(_ delta: PageDelta) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        guard WCSession.default.isReachable else {
            Self.logger.warning("iPhone not reachable")
            return
        }

        do {
            let data = try JSONEncoder().encode(delta)
            WCSession.default.sendMessage(
                ["pageDelta": data],
                replyHandler: nil,
                errorHandler: { error in
                    Self.logger.error("Failed to send: \(error)")
                }
            )
            Self.logger.info("Sent page delta: \(delta.delta)")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendSessionToPhone(_ session: ReadingSession) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        guard WCSession.default.isReachable else {
            Self.logger.warning("iPhone not reachable - session will sync later")
            return
        }

        guard let bookId = session.book?.id else {
            Self.logger.warning("Session has no book")
            return
        }

        do {
            let transfer = SessionTransfer(
                id: session.id,
                bookId: bookId,
                startDate: session.startDate,
                endDate: session.endDate,
                startPage: session.startPage,
                endPage: session.endPage,
                durationMinutes: session.durationMinutes,
                xpEarned: session.xpEarned,
                isAutoGenerated: session.isAutoGenerated
            )

            let data = try JSONEncoder().encode(transfer)
            WCSession.default.sendMessage(
                ["session": data],
                replyHandler: nil,
                errorHandler: { error in
                    Self.logger.error("Failed to send session: \(error)")
                }
            )
            Self.logger.info("Sent session to iPhone: \(session.endPage - session.startPage) pages, \(session.xpEarned) XP")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendProfileSettingsToPhone(_ profile: UserProfile) {
        guard WCSession.default.activationState == .activated else { return }
        guard WCSession.default.isReachable else { return }

        do {
            let transfer = ProfileSettingsTransfer(
                hideAutoSessionsIPhone: profile.hideAutoSessionsIPhone,
                hideAutoSessionsWatch: profile.hideAutoSessionsWatch
            )
            let data = try JSONEncoder().encode(transfer)
            WCSession.default.sendMessage(
                ["profileSettings": data],
                replyHandler: nil,
                errorHandler: { error in
                    Self.logger.error("Failed to send profile settings: \(error)")
                }
            )
            Self.logger.info("Sent profile settings to iPhone")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendProfileStatsToPhone(_ profile: UserProfile) {
        guard WCSession.default.activationState == .activated else { return }
        guard WCSession.default.isReachable else { return }

        do {
            let transfer = ProfileStatsTransfer(
                totalXP: profile.totalXP,
                currentStreak: profile.currentStreak,
                longestStreak: profile.longestStreak,
                lastReadingDate: profile.lastReadingDate
            )
            let data = try JSONEncoder().encode(transfer)
            WCSession.default.sendMessage(
                ["profileStats": data],
                replyHandler: nil,
                errorHandler: { error in
                    Self.logger.error("Failed to send profile stats: \(error)")
                }
            )
            Self.logger.info("Sent profile stats to iPhone: XP=\(profile.totalXP), Streak=\(profile.currentStreak)")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }
}

extension WatchConnectivityManager: WCSessionDelegate {
    nonisolated func session(
        _ session: WCSession,
        activationDidCompleteWith activationState: WCSessionActivationState,
        error: Error?
    ) {
        if let error = error {
            Self.logger.error("WC activation error: \(error)")
        } else {
            Self.logger.info("WC activated: \(activationState.rawValue)")
        }
    }

    nonisolated func session(
        _ session: WCSession,
        didReceiveMessage message: [String: Any]
    ) {
        Self.logger.info("Watch received message")

        // Handle page delta from iPhone
        if let pageDeltaData = message["pageDelta"] as? Data {
            Task { @MainActor in
                do {
                    let delta = try JSONDecoder().decode(PageDelta.self, from: pageDeltaData)
                    Self.logger.info("Received page delta from iPhone: \(delta.delta)")
                    await self.handlePageDeltaFromPhone(delta)
                } catch {
                    Self.logger.error("Page delta decoding error: \(error)")
                }
            }
        }

        // Handle profile settings from iPhone
        if let profileData = message["profileSettings"] as? Data {
            Task { @MainActor in
                do {
                    let settings = try JSONDecoder().decode(ProfileSettingsTransfer.self, from: profileData)
                    Self.logger.info("Received profile settings from iPhone")
                    await self.handleProfileSettings(settings)
                } catch {
                    Self.logger.error("Profile settings decoding error: \(error)")
                }
            }
        }

        // Handle profile stats from iPhone
        if let statsData = message["profileStats"] as? Data {
            Task { @MainActor in
                do {
                    let stats = try JSONDecoder().decode(ProfileStatsTransfer.self, from: statsData)
                    Self.logger.info("Received profile stats from iPhone: XP=\(stats.totalXP), Streak=\(stats.currentStreak)")
                    await self.handleProfileStats(stats)
                } catch {
                    Self.logger.error("Profile stats decoding error: \(error)")
                }
            }
        }
    }

    @MainActor
    private func handleProfileSettings(_ settings: ProfileSettingsTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let descriptor = FetchDescriptor<UserProfile>()
            let profiles = try modelContext.fetch(descriptor)

            if let profile = profiles.first {
                profile.hideAutoSessionsIPhone = settings.hideAutoSessionsIPhone
                profile.hideAutoSessionsWatch = settings.hideAutoSessionsWatch
                try modelContext.save()
                Self.logger.info("Updated profile settings from iPhone")
            }
        } catch {
            Self.logger.error("Failed to update profile settings: \(error)")
        }
    }

    @MainActor
    private func handleProfileStats(_ stats: ProfileStatsTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let descriptor = FetchDescriptor<UserProfile>()
            let profiles = try modelContext.fetch(descriptor)

            if let profile = profiles.first {
                profile.totalXP = stats.totalXP
                profile.currentStreak = stats.currentStreak
                profile.longestStreak = stats.longestStreak
                profile.lastReadingDate = stats.lastReadingDate
                try modelContext.save()
                Self.logger.info("Updated profile stats from iPhone: XP=\(stats.totalXP), Streak=\(stats.currentStreak)")
            }
        } catch {
            Self.logger.error("Failed to update profile stats: \(error)")
        }
    }

    @MainActor
    private func handlePageDeltaFromPhone(_ delta: PageDelta) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            // Fetch the book by UUID
            let descriptor = FetchDescriptor<Book>(
                predicate: #Predicate<Book> { book in
                    book.id == delta.bookUUID
                }
            )
            let books = try modelContext.fetch(descriptor)

            guard let book = books.first else {
                Self.logger.warning("Book not found with UUID: \(delta.bookUUID)")
                return
            }

            // Update current page
            let oldPage = book.currentPage
            book.currentPage = min((book.totalPages ?? 1000), book.currentPage + delta.delta)

            // Save context
            try modelContext.save()

            Self.logger.info("Updated book from iPhone: \(book.title) from page \(oldPage) to \(book.currentPage)")
        } catch {
            Self.logger.error("Failed to update book from iPhone delta: \(error)")
        }
    }

    nonisolated func session(
        _ session: WCSession,
        didReceiveApplicationContext applicationContext: [String: Any]
    ) {
        Self.logger.info("Watch received application context")

        let booksData = applicationContext["books"] as? Data
        let sessionsData = applicationContext["sessions"] as? Data

        if booksData == nil && sessionsData == nil {
            Self.logger.warning("No data in context")
            return
        }

        Task { @MainActor in
            if let booksData = booksData {
                await self.handleBooksSync(booksData)
            }
            if let sessionsData = sessionsData {
                await self.handleSessionsSync(sessionsData)
            }
        }
    }

    @MainActor
    private func handleBooksSync(_ booksData: Data) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let bookTransfers = try JSONDecoder().decode([BookTransfer].self, from: booksData)
            Self.logger.info("Received \(bookTransfers.count) books from iPhone")

            // Fetch existing books
            let descriptor = FetchDescriptor<Book>()
            let existingBooks = try modelContext.fetch(descriptor)

            // Create a map of existing books by UUID for fast lookup
            var existingBooksMap = [UUID: Book]()
            for book in existingBooks {
                existingBooksMap[book.id] = book
            }

            // Track which UUIDs are in the transfer
            var transferredUUIDs = Set<UUID>()

            // Update or insert books
            for transfer in bookTransfers {
                transferredUUIDs.insert(transfer.id)

                if let existingBook = existingBooksMap[transfer.id] {
                    // Update existing book
                    existingBook.title = transfer.title
                    existingBook.author = transfer.author
                    existingBook.isbn = transfer.isbn
                    if let urlString = transfer.coverImageURL {
                        existingBook.coverImageURL = URL(string: urlString)
                    } else {
                        existingBook.coverImageURL = nil
                    }
                    existingBook.totalPages = transfer.totalPages
                    existingBook.currentPage = transfer.currentPage
                    existingBook.bookTypeRawValue = transfer.bookTypeRawValue
                    existingBook.readingStatusRawValue = transfer.readingStatusRawValue
                    existingBook.dateAdded = transfer.dateAdded
                    existingBook.notes = transfer.notes
                } else {
                    // Insert new book
                    let book = Book(
                        id: transfer.id,
                        title: transfer.title,
                        author: transfer.author,
                        isbn: transfer.isbn,
                        coverImageURL: transfer.coverImageURL != nil ? URL(string: transfer.coverImageURL!) : nil,
                        totalPages: transfer.totalPages,
                        currentPage: transfer.currentPage,
                        bookType: BookType(rawValue: transfer.bookTypeRawValue) ?? .physical,
                        readingStatus: ReadingStatus(rawValue: transfer.readingStatusRawValue) ?? .wantToRead,
                        dateAdded: transfer.dateAdded,
                        notes: transfer.notes
                    )
                    modelContext.insert(book)
                }
            }

            // Delete books that are no longer in the iPhone's currently reading list
            for existingBook in existingBooks {
                if !transferredUUIDs.contains(existingBook.id) {
                    modelContext.delete(existingBook)
                }
            }

            try modelContext.save()
            Self.logger.info("Synced \(bookTransfers.count) books to Watch")
        } catch {
            Self.logger.error("Failed to handle books sync: \(error)")
        }
    }

    @MainActor
    private func handleSessionsSync(_ sessionsData: Data) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let sessionTransfers = try JSONDecoder().decode([SessionTransfer].self, from: sessionsData)
            Self.logger.info("Received \(sessionTransfers.count) sessions from iPhone")

            // Fetch existing sessions
            let descriptor = FetchDescriptor<ReadingSession>()
            let existingSessions = try modelContext.fetch(descriptor)

            // Create a map of existing sessions by UUID
            var existingSessionsMap = [UUID: ReadingSession]()
            for session in existingSessions {
                existingSessionsMap[session.id] = session
            }

            // Fetch all books to link sessions
            let booksDescriptor = FetchDescriptor<Book>()
            let allBooks = try modelContext.fetch(booksDescriptor)
            var booksMap = [UUID: Book]()
            for book in allBooks {
                booksMap[book.id] = book
            }

            // Update or insert sessions (MERGE, don't delete local sessions)
            for transfer in sessionTransfers {
                guard let book = booksMap[transfer.bookId] else {
                    Self.logger.warning("Book not found for session: \(transfer.bookId)")
                    continue
                }

                if let existingSession = existingSessionsMap[transfer.id] {
                    // Update existing session (iPhone data takes precedence)
                    existingSession.startDate = transfer.startDate
                    existingSession.endDate = transfer.endDate
                    existingSession.startPage = transfer.startPage
                    existingSession.endPage = transfer.endPage
                    existingSession.durationMinutes = transfer.durationMinutes
                    existingSession.xpEarned = transfer.xpEarned
                    existingSession.isAutoGenerated = transfer.isAutoGenerated
                    existingSession.book = book
                } else {
                    // Insert new session from iPhone
                    let session = ReadingSession(
                        id: transfer.id,
                        startDate: transfer.startDate,
                        endDate: transfer.endDate,
                        startPage: transfer.startPage,
                        endPage: transfer.endPage,
                        durationMinutes: transfer.durationMinutes,
                        xpEarned: transfer.xpEarned,
                        isAutoGenerated: transfer.isAutoGenerated,
                        book: book
                    )
                    modelContext.insert(session)
                }
            }

            // DON'T delete Watch-created sessions - we'll merge them instead

            try modelContext.save()
            Self.logger.info("Synced \(sessionTransfers.count) sessions to Watch")
        } catch {
            Self.logger.error("Failed to handle sessions sync: \(error)")
        }
    }
}
