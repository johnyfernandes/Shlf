//
//  WatchConnectivityManager.swift
//  ShlfWatch Watch App
//
//  Created by Jo√£o Fernandes on 27/11/2025.
//

import Foundation
import WatchConnectivity
import SwiftData
import OSLog
// Transfer models provided by Shared/ConnectivityTransfers.swift

private enum ReadingConstants {
    static let defaultMaxPages = 1000
}

class WatchConnectivityManager: NSObject {
    static let shared = WatchConnectivityManager()
    nonisolated(unsafe) static let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "com.shlf.watch", category: "WatchSync")
    private var modelContext: ModelContext?

    private override init() {
        super.init()
    }

    func configure(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func activate() {
        guard WCSession.isSupported() else { return }
        let session = WCSession.default
        session.delegate = self
        session.activate()
        Self.logger.info("WatchConnectivity activated on Watch")
    }

    func sendPageDelta(_ delta: PageDelta) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        do {
            let data = try JSONEncoder().encode(delta)
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["pageDelta": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send: \(error)")
                    }
                )
                Self.logger.info("Sent page delta: \(delta.delta)")
            } else {
                WCSession.default.transferUserInfo(["pageDelta": data])
                Self.logger.info("Queued page delta: \(delta.delta)")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendSessionToPhone(_ session: ReadingSession) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        guard let bookId = session.book?.id else {
            Self.logger.warning("Session has no book")
            return
        }

        do {
            let transfer = SessionTransfer(
                id: session.id,
                bookId: bookId,
                startDate: session.startDate,
                endDate: session.endDate,
                startPage: session.startPage,
                endPage: session.endPage,
                durationMinutes: session.durationMinutes,
                xpEarned: session.xpEarned,
                isAutoGenerated: session.isAutoGenerated
            )

            let data = try JSONEncoder().encode(transfer)
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["session": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send session: \(error)")
                    }
                )
                Self.logger.info("Sent session to iPhone: \(session.endPage - session.startPage) pages, \(session.xpEarned) XP")
            } else {
                WCSession.default.transferUserInfo(["session": data])
                Self.logger.info("Queued session to iPhone: \(session.endPage - session.startPage) pages, \(session.xpEarned) XP")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendProfileSettingsToPhone(_ profile: UserProfile) {
        guard WCSession.default.activationState == .activated else { return }

        do {
            let transfer = ProfileSettingsTransfer(
                hideAutoSessionsIPhone: profile.hideAutoSessionsIPhone,
                hideAutoSessionsWatch: profile.hideAutoSessionsWatch,
                showSettingsOnWatch: profile.showSettingsOnWatch
            )
            let data = try JSONEncoder().encode(transfer)
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["profileSettings": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send profile settings: \(error)")
                    }
                )
                Self.logger.info("Sent profile settings to iPhone")
            } else {
                WCSession.default.transferUserInfo(["profileSettings": data])
                Self.logger.info("Queued profile settings to iPhone")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendProfileStatsToPhone(_ profile: UserProfile) {
        guard WCSession.default.activationState == .activated else { return }

        do {
            let transfer = ProfileStatsTransfer(
                totalXP: profile.totalXP,
                currentStreak: profile.currentStreak,
                longestStreak: profile.longestStreak,
                lastReadingDate: profile.lastReadingDate
            )
            let data = try JSONEncoder().encode(transfer)
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["profileStats": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send profile stats: \(error)")
                    }
                )
                Self.logger.info("Sent profile stats to iPhone: XP=\(profile.totalXP), Streak=\(profile.currentStreak)")
            } else {
                WCSession.default.transferUserInfo(["profileStats": data])
                Self.logger.info("Queued profile stats to iPhone: XP=\(profile.totalXP), Streak=\(profile.currentStreak)")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    // MARK: - Active Session Sync

    func sendActiveSessionToPhone(_ activeSession: ActiveReadingSession) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        guard let bookId = activeSession.book?.id else {
            Self.logger.warning("Cannot send active session without book")
            return
        }

        do {
            let transfer = ActiveSessionTransfer(
                id: activeSession.id,
                bookId: bookId,
                startDate: activeSession.startDate,
                currentPage: activeSession.currentPage,
                startPage: activeSession.startPage,
                isPaused: activeSession.isPaused,
                pausedAt: activeSession.pausedAt,
                totalPausedDuration: activeSession.totalPausedDuration,
                lastUpdated: activeSession.lastUpdated,
                sourceDevice: activeSession.sourceDevice
            )

            let data = try JSONEncoder().encode(transfer)
            // Use transferUserInfo to avoid blocking the main thread on sendMessage handshakes.
            WCSession.default.transferUserInfo(["activeSession": data])
            Self.logger.info("üì¶ Queued active session (guaranteed): \(activeSession.pagesRead) pages")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendActiveSessionEndToPhone() {
        guard WCSession.default.activationState == .activated else { return }

        if WCSession.default.isReachable {
            WCSession.default.sendMessage(
                ["activeSessionEnd": true],
                replyHandler: nil,
                errorHandler: { error in
                    Self.logger.error("‚ùå Failed to send active session end: \(error)")
                    WCSession.default.transferUserInfo(["activeSessionEnd": true])
                    Self.logger.info("‚Ü©Ô∏è Auto-fallback: Queued active session end")
                }
            )
            Self.logger.info("üì§ Sent active session end (instant)")
        } else {
            WCSession.default.transferUserInfo(["activeSessionEnd": true])
            Self.logger.info("üì¶ Queued active session end (guaranteed)")
        }
    }

    // MARK: - Live Activity Sync

    func sendLiveActivityStart(bookTitle: String, bookAuthor: String, totalPages: Int, startPage: Int, currentPage: Int, startTime: Date) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        do {
            let transfer = LiveActivityStartTransfer(
                bookTitle: bookTitle,
                bookAuthor: bookAuthor,
                totalPages: totalPages,
                startPage: startPage,
                currentPage: currentPage,
                startTime: startTime
            )
            let data = try JSONEncoder().encode(transfer)

            // Use sendMessage for instant delivery if reachable
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["liveActivityStart": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send Live Activity start: \(error)")
                        // Fallback to transferUserInfo if sendMessage fails
                        WCSession.default.transferUserInfo(["liveActivityStart": data])
                    }
                )
                Self.logger.info("üì§ Sent Live Activity start (instant): \(bookTitle)")
            } else {
                // Use transferUserInfo for guaranteed delivery even when iPhone is backgrounded
                WCSession.default.transferUserInfo(["liveActivityStart": data])
                Self.logger.info("üì¶ Queued Live Activity start (guaranteed): \(bookTitle)")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendLiveActivityUpdate(currentPage: Int, xpEarned: Int) {
        guard WCSession.default.activationState == .activated else { return }

        do {
            let transfer = LiveActivityUpdateTransfer(currentPage: currentPage, xpEarned: xpEarned)
            let data = try JSONEncoder().encode(transfer)
            // Use transferUserInfo so frequent updates don't hitch the UI and still arrive if unreachable.
            WCSession.default.transferUserInfo(["liveActivityUpdate": data])
            Self.logger.info("üì¶ Queued Live Activity update: page \(currentPage), XP \(xpEarned)")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendLiveActivityPause() {
        guard WCSession.default.activationState == .activated else { return }
        guard WCSession.default.isReachable else { return }

        do {
            let transfer = LiveActivityStateTransfer(isPaused: true)
            let data = try JSONEncoder().encode(transfer)
            WCSession.default.sendMessage(
                ["liveActivityState": data],
                replyHandler: nil,
                errorHandler: { error in
                    Self.logger.error("Failed to send Live Activity pause: \(error)")
                }
            )
            Self.logger.info("Sent Live Activity pause to iPhone")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendLiveActivityResume() {
        guard WCSession.default.activationState == .activated else { return }
        guard WCSession.default.isReachable else { return }

        do {
            let transfer = LiveActivityStateTransfer(isPaused: false)
            let data = try JSONEncoder().encode(transfer)
            WCSession.default.sendMessage(
                ["liveActivityState": data],
                replyHandler: nil,
                errorHandler: { error in
                    Self.logger.error("Failed to send Live Activity resume: \(error)")
                }
            )
            Self.logger.info("Sent Live Activity resume to iPhone")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendLiveActivityEnd() {
        guard WCSession.default.activationState == .activated else { return }
        guard WCSession.default.isReachable else { return }

        WCSession.default.sendMessage(
            ["liveActivityEnd": true],
            replyHandler: nil,
            errorHandler: { error in
                Self.logger.error("Failed to send Live Activity end: \(error)")
            }
        )
        Self.logger.info("Sent Live Activity end to iPhone")
    }
}

extension WatchConnectivityManager: WCSessionDelegate {
    nonisolated func session(
        _ session: WCSession,
        activationDidCompleteWith activationState: WCSessionActivationState,
        error: Error?
    ) {
        if let error = error {
            Self.logger.error("WC activation error: \(error)")
        } else {
            Self.logger.info("WC activated: \(activationState.rawValue)")
        }
    }

    nonisolated func session(
        _ session: WCSession,
        didReceiveMessage message: [String: Any]
    ) {
        Self.logger.info("Watch received message")

        // Handle page delta from iPhone
        if let pageDeltaData = message["pageDelta"] as? Data {
            Task { @MainActor in
                do {
                    let delta = try JSONDecoder().decode(PageDelta.self, from: pageDeltaData)
                    Self.logger.info("Received page delta from iPhone: \(delta.delta)")
                    await self.handlePageDeltaFromPhone(delta)
                } catch {
                    Self.logger.error("Page delta decoding error: \(error)")
                }
            }
        }

        // Handle profile settings from iPhone
        if let profileData = message["profileSettings"] as? Data {
            Task { @MainActor in
                do {
                    let settings = try JSONDecoder().decode(ProfileSettingsTransfer.self, from: profileData)
                    Self.logger.info("Received profile settings from iPhone")
                    await self.handleProfileSettings(settings)
                } catch {
                    Self.logger.error("Profile settings decoding error: \(error)")
                }
            }
        }

        // Handle profile stats from iPhone
        if let statsData = message["profileStats"] as? Data {
            Task { @MainActor in
                do {
                    let stats = try JSONDecoder().decode(ProfileStatsTransfer.self, from: statsData)
                    Self.logger.info("Received profile stats from iPhone: XP=\(stats.totalXP), Streak=\(stats.currentStreak)")
                    await self.handleProfileStats(stats)
                } catch {
                    Self.logger.error("Profile stats decoding error: \(error)")
                }
            }
        }

        // Handle single session from iPhone (for immediate sync)
        if let sessionData = message["session"] as? Data {
            Task { @MainActor in
                do {
                    let sessionTransfer = try JSONDecoder().decode(SessionTransfer.self, from: sessionData)
                    Self.logger.info("Received session from iPhone: \(sessionTransfer.endPage - sessionTransfer.startPage) pages")
                    await self.handleSessionFromPhone(sessionTransfer)
                } catch {
                    Self.logger.error("Session decoding error: \(error)")
                }
            }
        }

        // Handle active session from iPhone
        if let activeSessionData = message["activeSession"] as? Data {
            Task { @MainActor in
                do {
                    let transfer = try JSONDecoder().decode(ActiveSessionTransfer.self, from: activeSessionData)
                    Self.logger.info("Received active session from iPhone: \(transfer.pagesRead) pages")
                    await self.handleActiveSession(transfer)
                } catch {
                    Self.logger.error("Active session decoding error: \(error)")
                }
            }
        }

        // Handle active session end from iPhone
        if message["activeSessionEnd"] != nil {
            Task { @MainActor in
                await self.handleActiveSessionEnd()
            }
        }
    }

    nonisolated func session(_ session: WCSession, didReceiveUserInfo userInfo: [String: Any]) {
        Self.logger.info("Watch received userInfo payload")

        if let pageDeltaData = userInfo["pageDelta"] as? Data {
            Task { @MainActor in
                do {
                    let delta = try JSONDecoder().decode(PageDelta.self, from: pageDeltaData)
                    Self.logger.info("Received queued page delta from iPhone: \(delta.delta)")
                    await self.handlePageDeltaFromPhone(delta)
                } catch {
                    Self.logger.error("Page delta userInfo decoding error: \(error)")
                }
            }
        }

        if let profileData = userInfo["profileSettings"] as? Data {
            Task { @MainActor in
                do {
                    let settings = try JSONDecoder().decode(ProfileSettingsTransfer.self, from: profileData)
                    Self.logger.info("Received queued profile settings from iPhone")
                    await self.handleProfileSettings(settings)
                } catch {
                    Self.logger.error("Profile settings userInfo decoding error: \(error)")
                }
            }
        }

        if let statsData = userInfo["profileStats"] as? Data {
            Task { @MainActor in
                do {
                    let stats = try JSONDecoder().decode(ProfileStatsTransfer.self, from: statsData)
                    Self.logger.info("Received queued profile stats from iPhone: XP=\(stats.totalXP), Streak=\(stats.currentStreak)")
                    await self.handleProfileStats(stats)
                } catch {
                    Self.logger.error("Profile stats userInfo decoding error: \(error)")
                }
            }
        }

        if let sessionData = userInfo["session"] as? Data {
            Task { @MainActor in
                do {
                    let sessionTransfer = try JSONDecoder().decode(SessionTransfer.self, from: sessionData)
                    Self.logger.info("Received queued session from iPhone: \(sessionTransfer.endPage - sessionTransfer.startPage) pages")
                    await self.handleSessionFromPhone(sessionTransfer)
                } catch {
                    Self.logger.error("Session userInfo decoding error: \(error)")
                }
            }
        }

        // Handle queued active session from iPhone
        if let activeSessionData = userInfo["activeSession"] as? Data {
            Task { @MainActor in
                do {
                    let transfer = try JSONDecoder().decode(ActiveSessionTransfer.self, from: activeSessionData)
                    Self.logger.info("üì¶ Received queued active session from iPhone: \(transfer.pagesRead) pages")
                    await self.handleActiveSession(transfer)
                } catch {
                    Self.logger.error("Active session userInfo decoding error: \(error)")
                }
            }
        }

        // Handle queued active session end from iPhone
        if userInfo["activeSessionEnd"] != nil {
            Task { @MainActor in
                await self.handleActiveSessionEnd()
            }
        }
    }

    @MainActor
    private func handleProfileSettings(_ settings: ProfileSettingsTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let descriptor = FetchDescriptor<UserProfile>()
            let profiles = try modelContext.fetch(descriptor)

            if let profile = profiles.first {
                profile.hideAutoSessionsIPhone = settings.hideAutoSessionsIPhone
                profile.hideAutoSessionsWatch = settings.hideAutoSessionsWatch
                profile.showSettingsOnWatch = settings.showSettingsOnWatch
                try modelContext.save()
                Self.logger.info("Updated profile settings from iPhone")
            }
        } catch {
            Self.logger.error("Failed to update profile settings: \(error)")
        }
    }

    @MainActor
    private func handleSessionFromPhone(_ transfer: SessionTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            // Ensure book exists
            let bookDescriptor = FetchDescriptor<Book>(
                predicate: #Predicate<Book> { book in
                    book.id == transfer.bookId
                }
            )
            let books = try modelContext.fetch(bookDescriptor)

            guard let book = books.first else {
                Self.logger.warning("Book not found for session: \(transfer.bookId)")
                return
            }

            // Check for existing session
            let sessionDescriptor = FetchDescriptor<ReadingSession>(
                predicate: #Predicate<ReadingSession> { session in
                    session.id == transfer.id
                }
            )
            let existing = try modelContext.fetch(sessionDescriptor)

            if let existingSession = existing.first {
                existingSession.startDate = transfer.startDate
                existingSession.endDate = transfer.endDate
                existingSession.startPage = transfer.startPage
                existingSession.endPage = transfer.endPage
                existingSession.durationMinutes = transfer.durationMinutes
                existingSession.xpEarned = transfer.xpEarned
                existingSession.isAutoGenerated = transfer.isAutoGenerated
            } else {
                let session = ReadingSession(
                    id: transfer.id,
                    startDate: transfer.startDate,
                    endDate: transfer.endDate,
                    startPage: transfer.startPage,
                    endPage: transfer.endPage,
                    durationMinutes: transfer.durationMinutes,
                    xpEarned: transfer.xpEarned,
                    isAutoGenerated: transfer.isAutoGenerated,
                    book: book
                )
                modelContext.insert(session)
            }

            // Align book progress
            let maxPages = book.totalPages ?? ReadingConstants.defaultMaxPages
            book.currentPage = min(maxPages, max(0, transfer.endPage))

            try modelContext.save()
            Self.logger.info("Applied session from iPhone to Watch: \(transfer.endPage - transfer.startPage) pages")
        } catch {
            Self.logger.error("Failed to handle session from iPhone: \(error)")
        }
    }

    @MainActor
    private func handleProfileStats(_ stats: ProfileStatsTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let descriptor = FetchDescriptor<UserProfile>()
            let profiles = try modelContext.fetch(descriptor)

            if let profile = profiles.first {
                profile.totalXP = stats.totalXP
                profile.currentStreak = stats.currentStreak
                profile.longestStreak = stats.longestStreak
                profile.lastReadingDate = stats.lastReadingDate
                try modelContext.save()
                Self.logger.info("Updated profile stats from iPhone: XP=\(stats.totalXP), Streak=\(stats.currentStreak)")
            }
        } catch {
            Self.logger.error("Failed to update profile stats: \(error)")
        }
    }

    @MainActor
    private func handlePageDeltaFromPhone(_ delta: PageDelta) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            // Fetch the book by UUID
            let descriptor = FetchDescriptor<Book>(
                predicate: #Predicate<Book> { book in
                    book.id == delta.bookUUID
                }
            )
            let books = try modelContext.fetch(descriptor)

            guard let book = books.first else {
                Self.logger.warning("Book not found with UUID: \(delta.bookUUID)")
                return
            }

            // Update current page
            let oldPage = book.currentPage
            book.currentPage = min((book.totalPages ?? 1000), book.currentPage + delta.delta)

            // Post notification so active timer sessions can update their state
            NotificationCenter.default.post(
                name: NSNotification.Name("PageDeltaFromPhone"),
                object: nil,
                userInfo: ["bookUUID": delta.bookUUID, "newPage": book.currentPage]
            )

            // Save context
            try modelContext.save()

            Self.logger.info("Updated book from iPhone: \(book.title) from page \(oldPage) to \(book.currentPage)")
        } catch {
            Self.logger.error("Failed to update book from iPhone delta: \(error)")
        }
    }

    nonisolated func session(
        _ session: WCSession,
        didReceiveApplicationContext applicationContext: [String: Any]
    ) {
        Self.logger.info("Watch received application context")

        let booksData = applicationContext["books"] as? Data
        let sessionsData = applicationContext["sessions"] as? Data

        if booksData == nil && sessionsData == nil {
            Self.logger.warning("No data in context")
            return
        }

        Task { @MainActor in
            if let booksData = booksData {
                await self.handleBooksSync(booksData)
            }
            if let sessionsData = sessionsData {
                await self.handleSessionsSync(sessionsData)
            }
        }
    }

    @MainActor
    private func handleBooksSync(_ booksData: Data) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let bookTransfers = try JSONDecoder().decode([BookTransfer].self, from: booksData)
            Self.logger.info("Received \(bookTransfers.count) books from iPhone")

            // Fetch existing books
            let descriptor = FetchDescriptor<Book>()
            let existingBooks = try modelContext.fetch(descriptor)

            // Create a map of existing books by UUID for fast lookup
            var existingBooksMap = [UUID: Book]()
            for book in existingBooks {
                existingBooksMap[book.id] = book
            }

            // Track which UUIDs are in the transfer
            var transferredUUIDs = Set<UUID>()

            // Update or insert books
            for transfer in bookTransfers {
                transferredUUIDs.insert(transfer.id)

                if let existingBook = existingBooksMap[transfer.id] {
                    // Update existing book
                    existingBook.title = transfer.title
                    existingBook.author = transfer.author
                    existingBook.isbn = transfer.isbn
                    if let urlString = transfer.coverImageURL {
                        existingBook.coverImageURL = URL(string: urlString)
                    } else {
                        existingBook.coverImageURL = nil
                    }
                    existingBook.totalPages = transfer.totalPages
                    existingBook.currentPage = transfer.currentPage
                    existingBook.bookTypeRawValue = transfer.bookTypeRawValue
                    existingBook.readingStatusRawValue = transfer.readingStatusRawValue
                    existingBook.dateAdded = transfer.dateAdded
                    existingBook.notes = transfer.notes
                } else {
                    // Insert new book
                    let book = Book(
                        id: transfer.id,
                        title: transfer.title,
                        author: transfer.author,
                        isbn: transfer.isbn,
                        coverImageURL: transfer.coverImageURL != nil ? URL(string: transfer.coverImageURL!) : nil,
                        totalPages: transfer.totalPages,
                        currentPage: transfer.currentPage,
                        bookType: BookType(rawValue: transfer.bookTypeRawValue) ?? .physical,
                        readingStatus: ReadingStatus(rawValue: transfer.readingStatusRawValue) ?? .wantToRead,
                        dateAdded: transfer.dateAdded,
                        notes: transfer.notes
                    )
                    modelContext.insert(book)
                }
            }

            // ‚úÖ NEVER DELETE BOOKS ON WATCH
            // Keep all books for offline access and to prevent crashes during active sessions
            // Books are only updated or added, never removed

            try modelContext.save()
            Self.logger.info("‚úÖ Synced \(bookTransfers.count) books to Watch (additive-only, no deletions)")
        } catch {
            Self.logger.error("Failed to handle books sync: \(error)")
        }
    }

    @MainActor
    private func handleSessionsSync(_ sessionsData: Data) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let sessionTransfers = try JSONDecoder().decode([SessionTransfer].self, from: sessionsData)
            Self.logger.info("Received \(sessionTransfers.count) sessions from iPhone")

            // Fetch existing sessions
            let descriptor = FetchDescriptor<ReadingSession>()
            let existingSessions = try modelContext.fetch(descriptor)

            // Create a map of existing sessions by UUID
            var existingSessionsMap = [UUID: ReadingSession]()
            for session in existingSessions {
                existingSessionsMap[session.id] = session
            }

            // Fetch all books to link sessions
            let booksDescriptor = FetchDescriptor<Book>()
            let allBooks = try modelContext.fetch(booksDescriptor)
            var booksMap = [UUID: Book]()
            for book in allBooks {
                booksMap[book.id] = book
            }

            // Update or insert sessions (MERGE, don't delete local sessions)
            for transfer in sessionTransfers {
                guard let book = booksMap[transfer.bookId] else {
                    Self.logger.warning("Book not found for session: \(transfer.bookId)")
                    continue
                }

                if let existingSession = existingSessionsMap[transfer.id] {
                    // Update existing session (iPhone data takes precedence)
                    existingSession.startDate = transfer.startDate
                    existingSession.endDate = transfer.endDate
                    existingSession.startPage = transfer.startPage
                    existingSession.endPage = transfer.endPage
                    existingSession.durationMinutes = transfer.durationMinutes
                    existingSession.xpEarned = transfer.xpEarned
                    existingSession.isAutoGenerated = transfer.isAutoGenerated
                    existingSession.book = book
                } else {
                    // Insert new session from iPhone
                    let session = ReadingSession(
                        id: transfer.id,
                        startDate: transfer.startDate,
                        endDate: transfer.endDate,
                        startPage: transfer.startPage,
                        endPage: transfer.endPage,
                        durationMinutes: transfer.durationMinutes,
                        xpEarned: transfer.xpEarned,
                        isAutoGenerated: transfer.isAutoGenerated,
                        book: book
                    )
                    modelContext.insert(session)
                }
            }

            // DON'T delete Watch-created sessions - we'll merge them instead

            try modelContext.save()
            Self.logger.info("Synced \(sessionTransfers.count) sessions to Watch")
        } catch {
            Self.logger.error("Failed to handle sessions sync: \(error)")
        }
    }

    // MARK: - Active Session Handlers

    @MainActor
    private func handleActiveSession(_ transfer: ActiveSessionTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            // Fetch existing session
            let descriptor = FetchDescriptor<ActiveReadingSession>()
            let existingSessions = try modelContext.fetch(descriptor)

            if let existingSession = existingSessions.first {
                // UPDATE in place - don't delete!
                existingSession.currentPage = transfer.currentPage
                existingSession.isPaused = transfer.isPaused
                existingSession.pausedAt = transfer.pausedAt
                existingSession.totalPausedDuration = transfer.totalPausedDuration
                existingSession.lastUpdated = transfer.lastUpdated
                Self.logger.info("‚úÖ Updated session from iPhone: \(transfer.pagesRead) pages")
            } else {
                // Find the book
                let bookDescriptor = FetchDescriptor<Book>(
                    predicate: #Predicate<Book> { book in
                        book.id == transfer.bookId
                    }
                )
                let books = try modelContext.fetch(bookDescriptor)

                guard let book = books.first else {
                    Self.logger.warning("Book not found: \(transfer.bookId)")
                    return
                }

                // Create NEW session only if none exists
                let activeSession = ActiveReadingSession(
                    id: transfer.id,
                    book: book,
                    startDate: transfer.startDate,
                    currentPage: transfer.currentPage,
                    startPage: transfer.startPage,
                    isPaused: transfer.isPaused,
                    pausedAt: transfer.pausedAt,
                    totalPausedDuration: transfer.totalPausedDuration,
                    lastUpdated: transfer.lastUpdated,
                    sourceDevice: transfer.sourceDevice
                )
                modelContext.insert(activeSession)
                Self.logger.info("‚úÖ Created session from iPhone: \(transfer.pagesRead) pages")
            }

            try modelContext.save()
        } catch {
            Self.logger.error("Failed to handle active session: \(error)")
        }
    }

    @MainActor
    private func handleActiveSessionEnd() async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            // Delete all active sessions
            let descriptor = FetchDescriptor<ActiveReadingSession>()
            let activeSessions = try modelContext.fetch(descriptor)

            for session in activeSessions {
                modelContext.delete(session)
            }

            try modelContext.save()
            Self.logger.info("Ended all active sessions from iPhone")
        } catch {
            Self.logger.error("Failed to end active sessions: \(error)")
        }
    }
}
