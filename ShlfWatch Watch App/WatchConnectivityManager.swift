//
//  WatchConnectivityManager.swift
//  ShlfWatch Watch App
//
//  Created by Jo√£o Fernandes on 27/11/2025.
//

import Foundation
import WatchConnectivity
import SwiftData
import OSLog

struct PageDelta: Codable, Sendable {
    let bookUUID: UUID
    let delta: Int
}

struct BookTransfer: Codable, Sendable {
    let id: UUID
    let title: String
    let author: String
    let isbn: String?
    let coverImageURL: String?
    let totalPages: Int?
    let currentPage: Int
    let bookTypeRawValue: String
    let readingStatusRawValue: String
    let dateAdded: Date
    let notes: String
}

struct SessionTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let startDate: Date
    let endDate: Date?
    let startPage: Int
    let endPage: Int
    let durationMinutes: Int
    let xpEarned: Int
    let isAutoGenerated: Bool
}

class WatchConnectivityManager: NSObject {
    static let shared = WatchConnectivityManager()
    nonisolated(unsafe) static let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "com.shlf.watch", category: "WatchSync")
    private var modelContext: ModelContext?

    private override init() {
        super.init()
    }

    func configure(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func activate() {
        guard WCSession.isSupported() else { return }
        let session = WCSession.default
        session.delegate = self
        session.activate()
        Self.logger.info("WatchConnectivity activated on Watch")
    }

    func sendPageDelta(_ delta: PageDelta) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        guard WCSession.default.isReachable else {
            Self.logger.warning("iPhone not reachable")
            return
        }

        do {
            let data = try JSONEncoder().encode(delta)
            WCSession.default.sendMessage(
                ["pageDelta": data],
                replyHandler: nil,
                errorHandler: { error in
                    Self.logger.error("Failed to send: \(error)")
                }
            )
            Self.logger.info("Sent page delta: \(delta.delta)")
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    @MainActor
    func syncSessionToPhone(_ session: ReadingSession) async {
        // Session sync will happen automatically via CloudKit
        // This is just a placeholder for future instant sync if needed
        Self.logger.info("Session created, will sync via CloudKit")
    }
}

extension WatchConnectivityManager: WCSessionDelegate {
    nonisolated func session(
        _ session: WCSession,
        activationDidCompleteWith activationState: WCSessionActivationState,
        error: Error?
    ) {
        if let error = error {
            Self.logger.error("WC activation error: \(error)")
        } else {
            Self.logger.info("WC activated: \(activationState.rawValue)")
        }
    }

    nonisolated func session(
        _ session: WCSession,
        didReceiveMessage message: [String: Any]
    ) {
        Self.logger.info("Watch received message")
        // Handle incoming deltas from iPhone if needed
    }

    nonisolated func session(
        _ session: WCSession,
        didReceiveApplicationContext applicationContext: [String: Any]
    ) {
        Self.logger.info("Watch received application context")

        let booksData = applicationContext["books"] as? Data
        let sessionsData = applicationContext["sessions"] as? Data

        if booksData == nil && sessionsData == nil {
            Self.logger.warning("No data in context")
            return
        }

        Task { @MainActor in
            if let booksData = booksData {
                await self.handleBooksSync(booksData)
            }
            if let sessionsData = sessionsData {
                await self.handleSessionsSync(sessionsData)
            }
        }
    }

    @MainActor
    private func handleBooksSync(_ booksData: Data) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let bookTransfers = try JSONDecoder().decode([BookTransfer].self, from: booksData)
            Self.logger.info("Received \(bookTransfers.count) books from iPhone")

            // Fetch existing books
            let descriptor = FetchDescriptor<Book>()
            let existingBooks = try modelContext.fetch(descriptor)

            // Create a map of existing books by UUID for fast lookup
            var existingBooksMap = [UUID: Book]()
            for book in existingBooks {
                existingBooksMap[book.id] = book
            }

            // Track which UUIDs are in the transfer
            var transferredUUIDs = Set<UUID>()

            // Update or insert books
            for transfer in bookTransfers {
                transferredUUIDs.insert(transfer.id)

                if let existingBook = existingBooksMap[transfer.id] {
                    // Update existing book
                    existingBook.title = transfer.title
                    existingBook.author = transfer.author
                    existingBook.isbn = transfer.isbn
                    if let urlString = transfer.coverImageURL {
                        existingBook.coverImageURL = URL(string: urlString)
                    } else {
                        existingBook.coverImageURL = nil
                    }
                    existingBook.totalPages = transfer.totalPages
                    existingBook.currentPage = transfer.currentPage
                    existingBook.bookTypeRawValue = transfer.bookTypeRawValue
                    existingBook.readingStatusRawValue = transfer.readingStatusRawValue
                    existingBook.dateAdded = transfer.dateAdded
                    existingBook.notes = transfer.notes
                } else {
                    // Insert new book
                    let book = Book(
                        id: transfer.id,
                        title: transfer.title,
                        author: transfer.author,
                        isbn: transfer.isbn,
                        coverImageURL: transfer.coverImageURL != nil ? URL(string: transfer.coverImageURL!) : nil,
                        totalPages: transfer.totalPages,
                        currentPage: transfer.currentPage,
                        bookType: BookType(rawValue: transfer.bookTypeRawValue) ?? .physical,
                        readingStatus: ReadingStatus(rawValue: transfer.readingStatusRawValue) ?? .wantToRead,
                        dateAdded: transfer.dateAdded,
                        notes: transfer.notes
                    )
                    modelContext.insert(book)
                }
            }

            // Delete books that are no longer in the iPhone's currently reading list
            for existingBook in existingBooks {
                if !transferredUUIDs.contains(existingBook.id) {
                    modelContext.delete(existingBook)
                }
            }

            try modelContext.save()
            Self.logger.info("Synced \(bookTransfers.count) books to Watch")
        } catch {
            Self.logger.error("Failed to handle books sync: \(error)")
        }
    }

    @MainActor
    private func handleSessionsSync(_ sessionsData: Data) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let sessionTransfers = try JSONDecoder().decode([SessionTransfer].self, from: sessionsData)
            Self.logger.info("Received \(sessionTransfers.count) sessions from iPhone")

            // Fetch existing sessions
            let descriptor = FetchDescriptor<ReadingSession>()
            let existingSessions = try modelContext.fetch(descriptor)

            // Create a map of existing sessions by UUID
            var existingSessionsMap = [UUID: ReadingSession]()
            for session in existingSessions {
                existingSessionsMap[session.id] = session
            }

            // Fetch all books to link sessions
            let booksDescriptor = FetchDescriptor<Book>()
            let allBooks = try modelContext.fetch(booksDescriptor)
            var booksMap = [UUID: Book]()
            for book in allBooks {
                booksMap[book.id] = book
            }

            // Track which session UUIDs are in the transfer
            var transferredUUIDs = Set<UUID>()

            // Update or insert sessions
            for transfer in sessionTransfers {
                transferredUUIDs.insert(transfer.id)

                guard let book = booksMap[transfer.bookId] else {
                    Self.logger.warning("Book not found for session: \(transfer.bookId)")
                    continue
                }

                if let existingSession = existingSessionsMap[transfer.id] {
                    // Update existing session
                    existingSession.startDate = transfer.startDate
                    existingSession.endDate = transfer.endDate
                    existingSession.startPage = transfer.startPage
                    existingSession.endPage = transfer.endPage
                    existingSession.durationMinutes = transfer.durationMinutes
                    existingSession.xpEarned = transfer.xpEarned
                    existingSession.isAutoGenerated = transfer.isAutoGenerated
                    existingSession.book = book
                } else {
                    // Insert new session
                    let session = ReadingSession(
                        id: transfer.id,
                        startDate: transfer.startDate,
                        endDate: transfer.endDate,
                        startPage: transfer.startPage,
                        endPage: transfer.endPage,
                        durationMinutes: transfer.durationMinutes,
                        xpEarned: transfer.xpEarned,
                        isAutoGenerated: transfer.isAutoGenerated,
                        book: book
                    )
                    modelContext.insert(session)
                }
            }

            // Delete sessions that are no longer on iPhone
            for existingSession in existingSessions {
                if !transferredUUIDs.contains(existingSession.id) {
                    modelContext.delete(existingSession)
                }
            }

            try modelContext.save()
            Self.logger.info("Synced \(sessionTransfers.count) sessions to Watch")
        } catch {
            Self.logger.error("Failed to handle sessions sync: \(error)")
        }
    }
}
