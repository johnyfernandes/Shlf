//
//  WatchConnectivityManager.swift
//  Shlf
//
//  Created by Jo√£o Fernandes on 28/11/2025.
//

import Foundation
import WatchConnectivity
import SwiftData
import OSLog

extension Notification.Name {
    static let watchReachabilityDidChange = Notification.Name("watchReachabilityDidChange")
    static let watchSessionReceived = Notification.Name("watchSessionReceived")
    static let watchStatsUpdated = Notification.Name("watchStatsUpdated")
}

private enum ReadingConstants {
    static let defaultMaxPages = 1000
}

class WatchConnectivityManager: NSObject {
    static let shared = WatchConnectivityManager()
    static let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "com.shlf.app", category: "WatchSync")

    private var modelContext: ModelContext?

    private override init() {
        super.init()
    }

    func configure(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func activate() {
        guard WCSession.isSupported() else { return }
        let session = WCSession.default
        session.delegate = self
        session.activate()
        Self.logger.info("WatchConnectivity activated on iPhone")
    }

    func sendPageDeltaToWatch(bookUUID: UUID, delta: Int) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        do {
            let pageDelta = PageDelta(bookUUID: bookUUID, delta: delta)
            let data = try JSONEncoder().encode(pageDelta)
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["pageDelta": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send page delta to Watch: \(error)")
                    }
                )
                Self.logger.info("Sent page delta to Watch: \(delta)")
            } else {
                WCSession.default.transferUserInfo(["pageDelta": data])
                Self.logger.info("Queued page delta to Watch: \(delta)")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendSessionToWatch(_ session: ReadingSession) {
        guard WCSession.default.activationState == .activated else {
            Self.logger.warning("WC not activated")
            return
        }

        guard let bookId = session.book?.id else {
            Self.logger.warning("Cannot send session without book")
            return
        }

        do {
            let transfer = SessionTransfer(
                id: session.id,
                bookId: bookId,
                startDate: session.startDate,
                endDate: session.endDate,
                startPage: session.startPage,
                endPage: session.endPage,
                durationMinutes: session.durationMinutes,
                xpEarned: session.xpEarned,
                isAutoGenerated: session.isAutoGenerated
            )

            let data = try JSONEncoder().encode(transfer)
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["session": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send session to Watch: \(error)")
                    }
                )
                Self.logger.info("Sent session to Watch: \(session.pagesRead) pages")
            } else {
                WCSession.default.transferUserInfo(["session": data])
                Self.logger.info("Queued session to Watch: \(session.pagesRead) pages")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendProfileSettingsToWatch(_ profile: UserProfile) {
        guard WCSession.default.activationState == .activated else { return }

        do {
            let transfer = ProfileSettingsTransfer(
                hideAutoSessionsIPhone: profile.hideAutoSessionsIPhone,
                hideAutoSessionsWatch: profile.hideAutoSessionsWatch,
                showSettingsOnWatch: profile.showSettingsOnWatch
            )
            let data = try JSONEncoder().encode(transfer)
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["profileSettings": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send profile settings: \(error)")
                    }
                )
                Self.logger.info("Sent profile settings to Watch")
            } else {
                WCSession.default.transferUserInfo(["profileSettings": data])
                Self.logger.info("Queued profile settings to Watch")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    func sendProfileStatsToWatch(_ profile: UserProfile) {
        guard WCSession.default.activationState == .activated else { return }

        do {
            let transfer = ProfileStatsTransfer(
                totalXP: profile.totalXP,
                currentStreak: profile.currentStreak,
                longestStreak: profile.longestStreak,
                lastReadingDate: profile.lastReadingDate
            )
            let data = try JSONEncoder().encode(transfer)
            if WCSession.default.isReachable {
                WCSession.default.sendMessage(
                    ["profileStats": data],
                    replyHandler: nil,
                    errorHandler: { error in
                        Self.logger.error("Failed to send profile stats: \(error)")
                    }
                )
                Self.logger.info("Sent profile stats to Watch: XP=\(profile.totalXP), Streak=\(profile.currentStreak)")
            } else {
                WCSession.default.transferUserInfo(["profileStats": data])
                Self.logger.info("Queued profile stats to Watch: XP=\(profile.totalXP), Streak=\(profile.currentStreak)")
            }
        } catch {
            Self.logger.error("Encoding error: \(error)")
        }
    }

    @MainActor
    func syncBooksToWatch() async {
        guard WCSession.default.activationState == .activated,
              let modelContext = modelContext else {
            Self.logger.warning("Cannot sync - WC not activated or context not configured")
            return
        }

        do {
            // Fetch all currently reading books
            let booksDescriptor = FetchDescriptor<Book>(
                sortBy: [SortDescriptor(\.title)]
            )
            let allBooks = try modelContext.fetch(booksDescriptor)
            let currentlyReading = allBooks.filter { $0.readingStatus == .currentlyReading }

            Self.logger.info("Syncing \(currentlyReading.count) books to Watch...")

            // Convert books to transferable format
            let bookTransfers = currentlyReading.map { book in
                BookTransfer(
                    id: book.id,
                    title: book.title,
                    author: book.author,
                    isbn: book.isbn,
                    coverImageURL: book.coverImageURL?.absoluteString,
                    totalPages: book.totalPages,
                    currentPage: book.currentPage,
                    bookTypeRawValue: book.bookTypeRawValue,
                    readingStatusRawValue: book.readingStatusRawValue,
                    dateAdded: book.dateAdded,
                    notes: book.notes
                )
            }

            // Fetch sessions for currently reading books
            let bookIds = currentlyReading.map { $0.id }
            let sessionsDescriptor = FetchDescriptor<ReadingSession>(
                sortBy: [SortDescriptor(\.startDate, order: .reverse)]
            )
            let allSessions = try modelContext.fetch(sessionsDescriptor)
            let relevantSessions = allSessions.filter { session in
                guard let book = session.book else { return false }
                return bookIds.contains(book.id)
            }

            Self.logger.info("Syncing \(relevantSessions.count) sessions to Watch...")

            // Convert sessions to transferable format
            let sessionTransfers = relevantSessions.compactMap { session -> SessionTransfer? in
                guard let bookId = session.book?.id else { return nil }
                return SessionTransfer(
                    id: session.id,
                    bookId: bookId,
                    startDate: session.startDate,
                    endDate: session.endDate,
                    startPage: session.startPage,
                    endPage: session.endPage,
                    durationMinutes: session.durationMinutes,
                    xpEarned: session.xpEarned,
                    isAutoGenerated: session.isAutoGenerated
                )
            }

            let booksData = try JSONEncoder().encode(bookTransfers)
            let sessionsData = try JSONEncoder().encode(sessionTransfers)

            // Use updateApplicationContext for guaranteed delivery
            try WCSession.default.updateApplicationContext([
                "books": booksData,
                "sessions": sessionsData
            ])
            Self.logger.info("Sent \(bookTransfers.count) books and \(sessionTransfers.count) sessions to Watch")
        } catch {
            Self.logger.error("Failed to sync to Watch: \(error)")
        }
    }
}

extension WatchConnectivityManager: WCSessionDelegate {
    nonisolated func session(
        _ session: WCSession,
        activationDidCompleteWith activationState: WCSessionActivationState,
        error: Error?
    ) {
        if let error = error {
            Self.logger.error("WC activation error: \(error)")
        } else {
            Self.logger.info("WC activated: \(activationState.rawValue)")
            // Sync books to watch when activated
            Task { @MainActor in
                await WatchConnectivityManager.shared.syncBooksToWatch()
            }
        }
    }

    nonisolated func sessionDidBecomeInactive(_ session: WCSession) {
        Self.logger.warning("WC session became inactive")
    }

    nonisolated func sessionDidDeactivate(_ session: WCSession) {
        Self.logger.warning("WC session deactivated")
        // Reactivate session for new watch
        session.activate()
    }

    nonisolated func sessionReachabilityDidChange(_ session: WCSession) {
        NotificationCenter.default.post(name: .watchReachabilityDidChange, object: nil)
    }

    nonisolated func session(
        _ session: WCSession,
        didReceiveMessage message: [String: Any]
    ) {
        Self.logger.info("iPhone received message")

        // Handle page delta
        if let pageDeltaData = message["pageDelta"] as? Data {
            Task { @MainActor in
                do {
                    let delta = try JSONDecoder().decode(PageDelta.self, from: pageDeltaData)
                    Self.logger.info("Received page delta: \(delta.delta) for book")
                    await self.handlePageDelta(delta)
                } catch {
                    Self.logger.error("Page delta decoding error: \(error)")
                }
            }
        }

        // Handle session from Watch
        if let sessionData = message["session"] as? Data {
            Task { @MainActor in
                do {
                    let sessionTransfer = try JSONDecoder().decode(SessionTransfer.self, from: sessionData)
                    Self.logger.info("Received session from Watch: \(sessionTransfer.endPage - sessionTransfer.startPage) pages")
                    await self.handleWatchSession(sessionTransfer)
                } catch {
                    Self.logger.error("Session decoding error: \(error)")
                }
            }
        }

        // Handle profile settings from Watch
        if let profileData = message["profileSettings"] as? Data {
            Task { @MainActor in
                do {
                    let settings = try JSONDecoder().decode(ProfileSettingsTransfer.self, from: profileData)
                    Self.logger.info("Received profile settings from Watch")
                    await self.handleProfileSettings(settings)
                } catch {
                    Self.logger.error("Profile settings decoding error: \(error)")
                }
            }
        }

        // Handle profile stats from Watch
        if let statsData = message["profileStats"] as? Data {
            Task { @MainActor in
                do {
                    let stats = try JSONDecoder().decode(ProfileStatsTransfer.self, from: statsData)
                    Self.logger.info("Received profile stats from Watch: XP=\(stats.totalXP), Streak=\(stats.currentStreak)")
                    await self.handleProfileStats(stats)
                } catch {
                    Self.logger.error("Profile stats decoding error: \(error)")
                }
            }
        }
    }

    nonisolated func session(_ session: WCSession, didReceiveUserInfo userInfo: [String: Any]) {
        Self.logger.info("iPhone received userInfo payload")

        if let pageDeltaData = userInfo["pageDelta"] as? Data {
            Task { @MainActor in
                do {
                    let delta = try JSONDecoder().decode(PageDelta.self, from: pageDeltaData)
                    Self.logger.info("Received queued page delta: \(delta.delta)")
                    await self.handlePageDelta(delta)
                } catch {
                    Self.logger.error("Page delta userInfo decoding error: \(error)")
                }
            }
        }

        if let sessionData = userInfo["session"] as? Data {
            Task { @MainActor in
                do {
                    let sessionTransfer = try JSONDecoder().decode(SessionTransfer.self, from: sessionData)
                    Self.logger.info("Received queued session from Watch: \(sessionTransfer.endPage - sessionTransfer.startPage) pages")
                    await self.handleWatchSession(sessionTransfer)
                } catch {
                    Self.logger.error("Session userInfo decoding error: \(error)")
                }
            }
        }

        if let profileData = userInfo["profileSettings"] as? Data {
            Task { @MainActor in
                do {
                    let settings = try JSONDecoder().decode(ProfileSettingsTransfer.self, from: profileData)
                    Self.logger.info("Received queued profile settings from Watch")
                    await self.handleProfileSettings(settings)
                } catch {
                    Self.logger.error("Profile settings userInfo decoding error: \(error)")
                }
            }
        }

        if let statsData = userInfo["profileStats"] as? Data {
            Task { @MainActor in
                do {
                    let stats = try JSONDecoder().decode(ProfileStatsTransfer.self, from: statsData)
                    Self.logger.info("Received queued profile stats from Watch: XP=\(stats.totalXP), Streak=\(stats.currentStreak)")
                    await self.handleProfileStats(stats)
                } catch {
                    Self.logger.error("Profile stats userInfo decoding error: \(error)")
                }
            }
        }
    }

    @MainActor
    private func handlePageDelta(_ delta: PageDelta) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            // Fetch the book by UUID
            let descriptor = FetchDescriptor<Book>(
                predicate: #Predicate<Book> { book in
                    book.id == delta.bookUUID
                }
            )
            let books = try modelContext.fetch(descriptor)

            guard let book = books.first else {
                Self.logger.warning("Book not found with UUID: \(delta.bookUUID)")
                return
            }

            // Update current page
            book.currentPage = min((book.totalPages ?? ReadingConstants.defaultMaxPages), book.currentPage + delta.delta)

            // Save context
            try modelContext.save()

            Self.logger.info("Updated book: \(book.title) to page \(book.currentPage)")

            // Update Live Activity if running
            await ReadingSessionActivityManager.shared.updateCurrentPage(book.currentPage)
        } catch {
            Self.logger.error("Failed to update book: \(error)")
        }
    }

    @MainActor
    private func handleWatchSession(_ transfer: SessionTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let engine = GamificationEngine(modelContext: modelContext)
            let sessionDate = transfer.endDate ?? transfer.startDate

            // Track XP difference if updating
            var xpDelta = 0
            var xpForActivity = 0

            // Check if session already exists
            let descriptor = FetchDescriptor<ReadingSession>(
                predicate: #Predicate<ReadingSession> { session in
                    session.id == transfer.id
                }
            )
            let existingSessions = try modelContext.fetch(descriptor)

            var bookForSession: Book?

            if let existingSession = existingSessions.first {
                // Update existing session
                let previousXP = existingSession.xpEarned
                existingSession.startDate = transfer.startDate
                existingSession.endDate = transfer.endDate
                existingSession.startPage = transfer.startPage
                existingSession.endPage = transfer.endPage
                existingSession.durationMinutes = transfer.durationMinutes
                existingSession.xpEarned = engine.calculateXP(for: existingSession)
                existingSession.isAutoGenerated = transfer.isAutoGenerated
                bookForSession = existingSession.book
                xpDelta = existingSession.xpEarned - previousXP
                xpForActivity = existingSession.xpEarned
                Self.logger.info("Updated existing session from Watch")
            } else {
                // Find the book
                let bookDescriptor = FetchDescriptor<Book>(
                    predicate: #Predicate<Book> { book in
                        book.id == transfer.bookId
                    }
                )
                let books = try modelContext.fetch(bookDescriptor)

                guard let book = books.first else {
                    Self.logger.warning("Book not found for Watch session: \(transfer.bookId)")
                    return
                }

                // Create new session
                let session = ReadingSession(
                    id: transfer.id,
                    startDate: transfer.startDate,
                    endDate: transfer.endDate,
                    startPage: transfer.startPage,
                    endPage: transfer.endPage,
                    durationMinutes: transfer.durationMinutes,
                    xpEarned: 0,
                    isAutoGenerated: transfer.isAutoGenerated,
                    book: book
                )
                session.xpEarned = engine.calculateXP(for: session)
                modelContext.insert(session)
                bookForSession = book
                xpDelta = session.xpEarned
                xpForActivity = session.xpEarned
                Self.logger.info("Created new session from Watch: \(transfer.endPage - transfer.startPage) pages, \(session.xpEarned) XP")
            }

            // Align book progress to session
            if let book = bookForSession {
                let maxPages = book.totalPages ?? ReadingConstants.defaultMaxPages
                book.currentPage = min(maxPages, max(0, transfer.endPage))
                await ReadingSessionActivityManager.shared.updateActivity(
                    currentPage: book.currentPage,
                    xpEarned: xpForActivity
                )
            }

            try modelContext.save()

            // Update profile stats with authoritative calculation
            let profileDescriptor = FetchDescriptor<UserProfile>()
            if let profile = try modelContext.fetch(profileDescriptor).first {
                if xpDelta != 0 {
                    engine.awardXP(xpDelta, to: profile)
                }
                engine.updateStreak(for: profile, sessionDate: sessionDate)
                engine.checkAchievements(for: profile)
                try modelContext.save()
                WidgetDataExporter.exportSnapshot(modelContext: modelContext)
                // Keep Watch in sync with latest stats
                sendProfileStatsToWatch(profile)
            }

            // Force UI refresh
            NotificationCenter.default.post(name: .watchSessionReceived, object: nil)
        } catch {
            Self.logger.error("Failed to handle Watch session: \(error)")
        }
    }

    @MainActor
    private func handleProfileSettings(_ settings: ProfileSettingsTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let descriptor = FetchDescriptor<UserProfile>()
            let profiles = try modelContext.fetch(descriptor)

            if let profile = profiles.first {
                profile.hideAutoSessionsIPhone = settings.hideAutoSessionsIPhone
                profile.hideAutoSessionsWatch = settings.hideAutoSessionsWatch
                profile.showSettingsOnWatch = settings.showSettingsOnWatch
                try modelContext.save()
                Self.logger.info("Updated profile settings from Watch")
            }
        } catch {
            Self.logger.error("Failed to update profile settings: \(error)")
        }
    }

    @MainActor
    private func handleProfileStats(_ stats: ProfileStatsTransfer) async {
        guard let modelContext = modelContext else {
            Self.logger.warning("ModelContext not configured")
            return
        }

        do {
            let descriptor = FetchDescriptor<UserProfile>()
            let profiles = try modelContext.fetch(descriptor)

            if let profile = profiles.first {
                profile.totalXP = stats.totalXP
                profile.currentStreak = stats.currentStreak
                profile.longestStreak = stats.longestStreak
                profile.lastReadingDate = stats.lastReadingDate
                try modelContext.save()
                Self.logger.info("Updated profile stats from Watch: XP=\(stats.totalXP), Streak=\(stats.currentStreak)")

                // Force UI refresh
                NotificationCenter.default.post(name: .watchStatsUpdated, object: nil)
            }
        } catch {
            Self.logger.error("Failed to update profile stats: \(error)")
        }
    }
}
