//
//  ConnectivityTransfers.swift
//  Shlf
//
//  Created by Codex on 03/02/2026.
//

import Foundation

struct PageDelta: Codable, Sendable {
    let bookUUID: UUID
    let delta: Int
    let newPage: Int?
    let timestamp: Date

    private enum CodingKeys: String, CodingKey {
        case bookUUID
        case delta
        case newPage
        case timestamp
    }

    init(bookUUID: UUID, delta: Int, newPage: Int? = nil, timestamp: Date = Date()) {
        self.bookUUID = bookUUID
        self.delta = delta
        self.newPage = newPage
        self.timestamp = timestamp
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        bookUUID = try container.decode(UUID.self, forKey: .bookUUID)
        delta = try container.decode(Int.self, forKey: .delta)
        newPage = try container.decodeIfPresent(Int.self, forKey: .newPage)
        timestamp = try container.decodeIfPresent(Date.self, forKey: .timestamp) ?? Date()
    }
}

struct BookTransfer: Codable, Sendable {
    let id: UUID
    let title: String
    let author: String
    let isbn: String?
    let coverImageURL: String?
    let totalPages: Int?
    let currentPage: Int
    let bookTypeRawValue: String
    let readingStatusRawValue: String
    let dateAdded: Date
    let notes: String
}

struct SessionTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let startDate: Date
    let endDate: Date?
    let startPage: Int
    let endPage: Int
    let durationMinutes: Int
    let xpEarned: Int
    let isAutoGenerated: Bool
    let countsTowardStats: Bool
    let isImported: Bool

    private enum CodingKeys: String, CodingKey {
        case id
        case bookId
        case startDate
        case endDate
        case startPage
        case endPage
        case durationMinutes
        case xpEarned
        case isAutoGenerated
        case countsTowardStats
        case isImported
    }

    init(
        id: UUID,
        bookId: UUID,
        startDate: Date,
        endDate: Date?,
        startPage: Int,
        endPage: Int,
        durationMinutes: Int,
        xpEarned: Int,
        isAutoGenerated: Bool,
        countsTowardStats: Bool = true,
        isImported: Bool = false
    ) {
        self.id = id
        self.bookId = bookId
        self.startDate = startDate
        self.endDate = endDate
        self.startPage = startPage
        self.endPage = endPage
        self.durationMinutes = durationMinutes
        self.xpEarned = xpEarned
        self.isAutoGenerated = isAutoGenerated
        self.countsTowardStats = countsTowardStats
        self.isImported = isImported
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(UUID.self, forKey: .id)
        bookId = try container.decode(UUID.self, forKey: .bookId)
        startDate = try container.decode(Date.self, forKey: .startDate)
        endDate = try container.decodeIfPresent(Date.self, forKey: .endDate)
        startPage = try container.decode(Int.self, forKey: .startPage)
        endPage = try container.decode(Int.self, forKey: .endPage)
        durationMinutes = try container.decode(Int.self, forKey: .durationMinutes)
        xpEarned = try container.decode(Int.self, forKey: .xpEarned)
        isAutoGenerated = try container.decode(Bool.self, forKey: .isAutoGenerated)
        countsTowardStats = try container.decodeIfPresent(Bool.self, forKey: .countsTowardStats) ?? true
        isImported = try container.decodeIfPresent(Bool.self, forKey: .isImported) ?? false
    }
}

struct ProfileSettingsTransfer: Codable, Sendable {
    let hideAutoSessionsIPhone: Bool
    let hideAutoSessionsWatch: Bool
    let showSettingsOnWatch: Bool
    let useCircularProgressWatch: Bool
    let enableWatchPositionMarking: Bool
    let themeColorRawValue: String
    let streaksPaused: Bool

    init(
        hideAutoSessionsIPhone: Bool,
        hideAutoSessionsWatch: Bool,
        showSettingsOnWatch: Bool = true,
        useCircularProgressWatch: Bool = false,
        enableWatchPositionMarking: Bool = true,
        themeColorRawValue: String = ThemeColor.blue.rawValue,
        streaksPaused: Bool = false
    ) {
        self.hideAutoSessionsIPhone = hideAutoSessionsIPhone
        self.hideAutoSessionsWatch = hideAutoSessionsWatch
        self.showSettingsOnWatch = showSettingsOnWatch
        self.useCircularProgressWatch = useCircularProgressWatch
        self.enableWatchPositionMarking = enableWatchPositionMarking
        self.themeColorRawValue = themeColorRawValue
        self.streaksPaused = streaksPaused
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let hideIPhone = try container.decode(Bool.self, forKey: .hideAutoSessionsIPhone)
        let hideWatch = try container.decode(Bool.self, forKey: .hideAutoSessionsWatch)
        let showSettings = try container.decodeIfPresent(Bool.self, forKey: .showSettingsOnWatch) ?? true
        let useCircular = try container.decodeIfPresent(Bool.self, forKey: .useCircularProgressWatch) ?? false
        let enablePosition = try container.decodeIfPresent(Bool.self, forKey: .enableWatchPositionMarking) ?? true
        let themeColor = try container.decodeIfPresent(String.self, forKey: .themeColorRawValue) ?? ThemeColor.blue.rawValue
        let streaksPaused = try container.decodeIfPresent(Bool.self, forKey: .streaksPaused) ?? false
        self.init(
            hideAutoSessionsIPhone: hideIPhone,
            hideAutoSessionsWatch: hideWatch,
            showSettingsOnWatch: showSettings,
            useCircularProgressWatch: useCircular,
            enableWatchPositionMarking: enablePosition,
            themeColorRawValue: themeColor,
            streaksPaused: streaksPaused
        )
    }
}

struct ProfileStatsTransfer: Codable, Sendable {
    let totalXP: Int
    let currentStreak: Int
    let longestStreak: Int
    let lastReadingDate: Date?
    let syncTimestamp: Date

    init(totalXP: Int, currentStreak: Int, longestStreak: Int, lastReadingDate: Date?, syncTimestamp: Date = Date()) {
        self.totalXP = totalXP
        self.currentStreak = currentStreak
        self.longestStreak = longestStreak
        self.lastReadingDate = lastReadingDate
        self.syncTimestamp = syncTimestamp
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        totalXP = try container.decode(Int.self, forKey: .totalXP)
        currentStreak = try container.decode(Int.self, forKey: .currentStreak)
        longestStreak = try container.decode(Int.self, forKey: .longestStreak)
        lastReadingDate = try container.decodeIfPresent(Date.self, forKey: .lastReadingDate)
        // For backward compatibility with old messages without timestamp
        syncTimestamp = try container.decodeIfPresent(Date.self, forKey: .syncTimestamp) ?? Date()
    }
}

struct LiveActivityStartTransfer: Codable, Sendable {
    let bookId: UUID?
    let bookTitle: String
    let bookAuthor: String
    let totalPages: Int
    let startPage: Int
    let currentPage: Int
    let startTime: Date
}

struct LiveActivityUpdateTransfer: Codable, Sendable {
    let currentPage: Int
    let xpEarned: Int
}

struct LiveActivityStateTransfer: Codable, Sendable {
    let isPaused: Bool

    // Used to drop stale pause/resume that arrive out of order
    let timestamp: Date

    private enum CodingKeys: String, CodingKey {
        case isPaused
        case timestamp
    }

    init(isPaused: Bool, timestamp: Date = Date()) {
        self.isPaused = isPaused
        self.timestamp = timestamp
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        isPaused = try container.decode(Bool.self, forKey: .isPaused)
        timestamp = try container.decodeIfPresent(Date.self, forKey: .timestamp) ?? Date()
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(isPaused, forKey: .isPaused)
        try container.encode(timestamp, forKey: .timestamp)
    }
}

struct ActiveSessionTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let startDate: Date
    let currentPage: Int
    let startPage: Int
    let isPaused: Bool
    let pausedAt: Date?
    let totalPausedDuration: TimeInterval
    let lastUpdated: Date
    let sourceDevice: String
    let sentAt: Date

    var pagesRead: Int {
        max(0, currentPage - startPage)
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case bookId
        case startDate
        case currentPage
        case startPage
        case isPaused
        case pausedAt
        case totalPausedDuration
        case lastUpdated
        case sourceDevice
        case sentAt
    }

    init(
        id: UUID,
        bookId: UUID,
        startDate: Date,
        currentPage: Int,
        startPage: Int,
        isPaused: Bool,
        pausedAt: Date?,
        totalPausedDuration: TimeInterval,
        lastUpdated: Date,
        sourceDevice: String,
        sentAt: Date = Date()
    ) {
        self.id = id
        self.bookId = bookId
        self.startDate = startDate
        self.currentPage = currentPage
        self.startPage = startPage
        self.isPaused = isPaused
        self.pausedAt = pausedAt
        self.totalPausedDuration = totalPausedDuration
        self.lastUpdated = lastUpdated
        self.sourceDevice = sourceDevice
        self.sentAt = sentAt
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(UUID.self, forKey: .id)
        bookId = try container.decode(UUID.self, forKey: .bookId)
        startDate = try container.decode(Date.self, forKey: .startDate)
        currentPage = try container.decode(Int.self, forKey: .currentPage)
        startPage = try container.decode(Int.self, forKey: .startPage)
        isPaused = try container.decode(Bool.self, forKey: .isPaused)
        pausedAt = try container.decodeIfPresent(Date.self, forKey: .pausedAt)
        totalPausedDuration = try container.decode(TimeInterval.self, forKey: .totalPausedDuration)
        lastUpdated = try container.decode(Date.self, forKey: .lastUpdated)
        sourceDevice = try container.decode(String.self, forKey: .sourceDevice)
        sentAt = try container.decodeIfPresent(Date.self, forKey: .sentAt) ?? Date()
    }
}

/// Consolidated transfer for session completion - replaces separate activeSessionEnd, session, and liveActivityEnd messages
struct SessionCompletionTransfer: Codable, Sendable {
    let activeSessionId: UUID
    let completedSession: SessionTransfer
    let endLiveActivity: Bool

    init(activeSessionId: UUID, completedSession: SessionTransfer, endLiveActivity: Bool = true) {
        self.activeSessionId = activeSessionId
        self.completedSession = completedSession
        self.endLiveActivity = endLiveActivity
    }
}

struct BookPositionTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let pageNumber: Int
    let lineNumber: Int?
    let timestamp: Date
    let note: String?
}

struct QuoteTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let text: String
    let pageNumber: Int?
    let dateAdded: Date
    let note: String?
    let isFavorite: Bool
}
