//
//  ConnectivityTransfers.swift
//  Shlf
//
//  Created by Codex on 03/02/2026.
//

import Foundation

struct PageDelta: Codable, Sendable {
    let bookUUID: UUID
    let delta: Int
}

struct BookTransfer: Codable, Sendable {
    let id: UUID
    let title: String
    let author: String
    let isbn: String?
    let coverImageURL: String?
    let totalPages: Int?
    let currentPage: Int
    let bookTypeRawValue: String
    let readingStatusRawValue: String
    let dateAdded: Date
    let notes: String
}

struct SessionTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let startDate: Date
    let endDate: Date?
    let startPage: Int
    let endPage: Int
    let durationMinutes: Int
    let xpEarned: Int
    let isAutoGenerated: Bool
}

struct ProfileSettingsTransfer: Codable, Sendable {
    let hideAutoSessionsIPhone: Bool
    let hideAutoSessionsWatch: Bool
    let showSettingsOnWatch: Bool
    let useCircularProgressWatch: Bool
    let themeColorRawValue: String

    init(
        hideAutoSessionsIPhone: Bool,
        hideAutoSessionsWatch: Bool,
        showSettingsOnWatch: Bool = true,
        useCircularProgressWatch: Bool = false,
        themeColorRawValue: String = ThemeColor.blue.rawValue
    ) {
        self.hideAutoSessionsIPhone = hideAutoSessionsIPhone
        self.hideAutoSessionsWatch = hideAutoSessionsWatch
        self.showSettingsOnWatch = showSettingsOnWatch
        self.useCircularProgressWatch = useCircularProgressWatch
        self.themeColorRawValue = themeColorRawValue
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let hideIPhone = try container.decode(Bool.self, forKey: .hideAutoSessionsIPhone)
        let hideWatch = try container.decode(Bool.self, forKey: .hideAutoSessionsWatch)
        let showSettings = try container.decodeIfPresent(Bool.self, forKey: .showSettingsOnWatch) ?? true
        let useCircular = try container.decodeIfPresent(Bool.self, forKey: .useCircularProgressWatch) ?? false
        let themeColor = try container.decodeIfPresent(String.self, forKey: .themeColorRawValue) ?? ThemeColor.blue.rawValue
        self.init(
            hideAutoSessionsIPhone: hideIPhone,
            hideAutoSessionsWatch: hideWatch,
            showSettingsOnWatch: showSettings,
            useCircularProgressWatch: useCircular,
            themeColorRawValue: themeColor
        )
    }
}

struct ProfileStatsTransfer: Codable, Sendable {
    let totalXP: Int
    let currentStreak: Int
    let longestStreak: Int
    let lastReadingDate: Date?
}

struct LiveActivityStartTransfer: Codable, Sendable {
    let bookId: UUID?
    let bookTitle: String
    let bookAuthor: String
    let totalPages: Int
    let startPage: Int
    let currentPage: Int
    let startTime: Date
}

struct LiveActivityUpdateTransfer: Codable, Sendable {
    let currentPage: Int
    let xpEarned: Int
}

struct LiveActivityStateTransfer: Codable, Sendable {
    let isPaused: Bool

    // Used to drop stale pause/resume that arrive out of order
    let timestamp: Date

    private enum CodingKeys: String, CodingKey {
        case isPaused
        case timestamp
    }

    init(isPaused: Bool, timestamp: Date = Date()) {
        self.isPaused = isPaused
        self.timestamp = timestamp
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        isPaused = try container.decode(Bool.self, forKey: .isPaused)
        timestamp = try container.decodeIfPresent(Date.self, forKey: .timestamp) ?? Date()
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(isPaused, forKey: .isPaused)
        try container.encode(timestamp, forKey: .timestamp)
    }
}

struct ActiveSessionTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let startDate: Date
    let currentPage: Int
    let startPage: Int
    let isPaused: Bool
    let pausedAt: Date?
    let totalPausedDuration: TimeInterval
    let lastUpdated: Date
    let sourceDevice: String

    var pagesRead: Int {
        max(0, currentPage - startPage)
    }
}

/// Consolidated transfer for session completion - replaces separate activeSessionEnd, session, and liveActivityEnd messages
struct SessionCompletionTransfer: Codable, Sendable {
    let activeSessionId: UUID
    let completedSession: SessionTransfer
    let endLiveActivity: Bool

    init(activeSessionId: UUID, completedSession: SessionTransfer, endLiveActivity: Bool = true) {
        self.activeSessionId = activeSessionId
        self.completedSession = completedSession
        self.endLiveActivity = endLiveActivity
    }
}

struct BookPositionTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let pageNumber: Int
    let lineNumber: Int?
    let timestamp: Date
    let note: String?
}

struct QuoteTransfer: Codable, Sendable {
    let id: UUID
    let bookId: UUID
    let text: String
    let pageNumber: Int?
    let dateAdded: Date
    let note: String?
    let isFavorite: Bool
}
