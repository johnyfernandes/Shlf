//
//  ReadingSession.swift
//  Shlf
//
//  Created by JoÃ£o Fernandes on 26/11/2025.
//

import Foundation
import SwiftData

/// Reading session model with comprehensive validation
///
/// ## Timezone Handling
/// - All dates stored as absolute timestamps (UTC internally)
/// - Displayed in UI using current timezone
/// - When user travels: sessions display in local time of current timezone
/// - Stats like "pages read today" use current timezone's midnight boundary
///
/// ## Multiple Active Sessions
/// - System enforces ONE total active session at a time
/// - Creating new active session replaces any existing one
/// - Users cannot track multiple books simultaneously in active state
///
/// ## Validation
/// - Use `isValid` to check comprehensive validity
/// - Use `hasValidDates` for date-specific validation
/// - Use `hasValidPages` for page number validation
/// - Use `validationErrors` for debugging invalid sessions
@Model
final class ReadingSession {
    var id: UUID = UUID()
    var startDate: Date = Date()
    var endDate: Date?
    var startPage: Int = 0
    var endPage: Int = 0
    var durationMinutes: Int = 0
    var xpEarned: Int = 0
    var isAutoGenerated: Bool = false
    var xpAwarded: Bool = false // Track if XP was already added to profile
    var book: Book?

    init(
        id: UUID = UUID(),
        startDate: Date = Date(),
        endDate: Date? = nil,
        startPage: Int,
        endPage: Int,
        durationMinutes: Int = 0,
        xpEarned: Int = 0,
        isAutoGenerated: Bool = false,
        book: Book? = nil
    ) {
        self.id = id
        self.startDate = startDate
        self.endDate = endDate
        self.startPage = startPage
        self.endPage = endPage
        self.durationMinutes = durationMinutes
        self.xpEarned = xpEarned
        self.isAutoGenerated = isAutoGenerated
        self.book = book
    }

    var pagesRead: Int {
        endPage - startPage // Allow negative values for corrections
    }

    var isActive: Bool {
        endDate == nil
    }

    /// Display name for the session showing page range
    var displayName: String {
        if isActive {
            return "Started at page \(startPage)"
        } else {
            return "From page \(startPage) to page \(endPage)"
        }
    }

    /// Validates page numbers are within reasonable limits
    var hasValidPages: Bool {
        let maxReasonablePage = 100_000 // Books longer than this are rare
        return startPage >= 0 &&
               endPage >= 0 &&
               startPage <= maxReasonablePage &&
               endPage <= maxReasonablePage &&
               abs(pagesRead) <= 10_000 // Single session shouldn't exceed 10k pages
    }

    /// Validates session dates for data integrity
    /// Returns true if dates are valid, false otherwise
    var hasValidDates: Bool {
        // Allow 60 second tolerance for clock drift
        let futureTolerance: TimeInterval = 60
        let now = Date()

        // startDate should not be too far in future
        guard startDate <= now.addingTimeInterval(futureTolerance) else {
            return false
        }

        // If endDate exists, it must be >= startDate
        if let endDate = endDate {
            guard endDate >= startDate else {
                return false
            }

            // endDate should not be in future (beyond tolerance)
            guard endDate <= now.addingTimeInterval(futureTolerance) else {
                return false
            }
        }

        // Dates should not be too far in past (10 years is reasonable limit)
        let tenYearsAgo = now.addingTimeInterval(-10 * 365 * 24 * 3600)
        guard startDate >= tenYearsAgo else {
            return false
        }

        return true
    }

    /// Duration in minutes, returns nil if dates are invalid
    var validDurationMinutes: Int? {
        guard hasValidDates, let endDate = endDate else {
            return nil
        }

        let duration = endDate.timeIntervalSince(startDate)
        guard duration >= 0 else { return nil }

        return max(0, Int(duration / 60))
    }

    /// Comprehensive validation of all session data
    var isValid: Bool {
        // Must have a book (orphaned sessions are invalid)
        guard book != nil else { return false }

        // Dates must be valid
        guard hasValidDates else { return false }

        // Pages must be reasonable
        guard hasValidPages else { return false }

        return true
    }

    /// Returns validation errors as array of strings (for debugging)
    var validationErrors: [String] {
        var errors: [String] = []

        if book == nil {
            errors.append("Session has no book (orphaned)")
        }

        if !hasValidDates {
            errors.append("Invalid dates (future dates or endDate < startDate)")
        }

        if !hasValidPages {
            errors.append("Invalid pages (negative, too large, or unreasonable range)")
        }

        return errors
    }
}
